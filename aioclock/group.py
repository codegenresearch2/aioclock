import asyncio\\nimport sys\\\nfrom functools import wraps\\\nfrom typing import Awaitable, Callable, TypeVar, Union\\\\nif sys.version_info < (3, 10):\\\\" from typing_extensions import ParamSpec\"\\\" else:\\\" from typing import ParamSpec\"\\\\nfrom fast_depends import inject\\\\\nfrom aioclock.provider import get_provider\\\\\nfrom aioclock.task import Task\\\\\nfrom aioclock.triggers import BaseTrigger\\\\\n\\\\nT = TypeVar(\"T\") \\\\\nP = ParamSpec(\"P\") \\\\n\\\\nclass Group:\\\\\ndef __init__(self, *, tasks: Union[list[Task], None] = None): \\\\\n    \"\"\" Group of tasks that will be run together.\\\\\n    Best use case is to have a good modularity and separation of concerns.\\\\\n    For example, you can have a group of tasks that are responsible for sending emails.\\\\\n    And another group of tasks that are responsible for sending notifications.\\\\\n    \"\"\" \\\\\n    self._tasks: list[Task] = tasks or [] \\\\\n\\\\n    def task(self, *, trigger: BaseTrigger): \\\\\n    \"\"\" Function used to decorate tasks, to be registered inside AioClock.\\\\\n    \"\"\" \\\\\n        def decorator(func: Callable[P, Awaitable[T]]) -> Callable[P, Awaitable[T]]: \\\\\n            @wraps(func) \\\\\n            async def wrapper(*args: P.args, **kwargs: P.kwargs) -> T: \\\\\n                return await func(*args, **kwargs) \\\\\n\\\\n            self._tasks.append( \\\\\n                Task( \\\\\n                    func=inject(wrapper, dependency_overrides_provider=get_provider()), \\\\\n                    trigger=trigger, \\\\\n                ) \\\\\n            ) \\\\\n            return wrapper \\\\\n        return decorator \\\\\n\\\\n    async def _run(self): \\\\\n    \"\"\" Just for purpose of being able to run all task in group \\\\\n    Private method, should not be used outside of the library \\\\\n    \"\"\" \\\\\n        await asyncio.gather( \\\\\n            *(task.run() for task in self._tasks), \\\\\n            return_exceptions=False, \\\\\n        ) \\\\\n}